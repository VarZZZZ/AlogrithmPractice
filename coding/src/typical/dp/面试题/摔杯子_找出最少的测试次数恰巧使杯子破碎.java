package typical.dp.面试题;

/**
 * @Author: ly
 * @Date: 2020/7/17 22:32
 * @Version 1.0
 */
public class 摔杯子_找出最少的测试次数恰巧使杯子破碎 {
    /**
     * 一种杯子，若在第N层被摔破，则在任何比N高的楼层均会破，
     * 若在第M层不破，则在任何比M低的楼层均不会破，给你两个这样的杯子，
     * 让你在100层高的楼层中测试，要求用最少的测试次数找出恰巧会使杯子破碎的楼层。
     */
    /**
     * 首先，我们以10为区间，则得出
     * （1,10）（11,20）（21,30）（31,40）（41,50）（51，60）（61,70）（71,80）（
     * 81,90）（91,100）则最大的需要20次，具体的方法是：
     * 先从10层摔下，若不碎，则从第二十层再摔，如此内推，我们可以找到一个临界区间，
     * 如（51,60），我们再从51开始，一层一层的往下摔，摔碎的那一点是临界点，
     * 则这样平均少于20次。
     *
     * 通过这个方法，我们可以知道，平均次数少于20次，
     * 则最优的结果毕竟是不会超过20次的。我们做这样的考虑，
     * 每一次比较，我们都让这一次比较的次数抵消掉前一次比较过的次数，
     * 亦即区间的范围逐渐减小，如（1,10）（11,19）（20,27）...（54,55）56 57 .... 100，
     * 这到了第56以后就不能保证该次比较的次数抵消掉上一次比较过的次数，
     * 这不成立，我们接着用12,13比较也不行，当我们用14时，
     * 我们可以得出范围为（1,14）（15，27）（28,39）... （96,99）100，则可以得出少于14次。
        假设在(1,14)内，最大是14次，在(15,27)内，最大也是14,100，最大也是14
     因此，当有100层的时候，最多需要n次试摔，使得 n+(n-1)+(n-2)+...+1 >= 100，

     */

    /**
     * 假设用dp[i][j]表示剩余i层，j个杯子时候最少需要多少次试摔。
     * （1）dp[i][1] = i，也就是说当只剩下一个杯子时，只能从第一层开始逐层向上试摔。
     * （2）dp[0][j] = 0，当只剩下0层时，只需要进行0次试摔。
     * （3）dp[1][j] = 1，当只剩下1层时，只需要进行1次试摔，前提是j>0
     * （4）dp[i][j] = min(1=<k<j)(max(dp[k-1][i-1], dp[j-k][i]) + 1)，
     * dp[k-1][i-1] 杯子破的情况，此时，需要在k-1层楼里面用i-1个杯子找到最少摔次数
     * dp[j-k][i] 表示杯子没破的情况，此时，需要在剩下的j-k中用i个杯子继续找
     * 也就是当杯子破和不破的时候分成两个子问题，分别求解，之后求子问题试摔次数的最大和作为这种分解方法的试摔次数，
     * 之后取这些所有分拆子问题的方法中，使子问题和最小的方法。
     * route[i][j]，表示剩下i层j个杯子时，下一次试摔的楼层。当j=1时，从这个范围内的最底层依次向最高层试摔。
     */

    private int getMin(int n,int k){
        int[][] dp = new int[n][k];




        for(int i=1;i<=n;i++){
            for(int j=1;j<=k;j++){

                for(int c=1;c<j;c++){ // dp[k][..]

                }

            }
        }




        return 0;

    }









}
